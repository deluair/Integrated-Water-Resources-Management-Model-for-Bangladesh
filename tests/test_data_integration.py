"""Tests for data integration between modules.

These tests verify that data loaded or generated by data modules
(DataLoader, SyntheticDataGenerator) is in the correct format and
can be consumed by the various simulation managers.
"""

import pytest
import pandas as pd
from unittest.mock import MagicMock, patch

from bangladesh_water_management.config import get_default_config
from bangladesh_water_management.data import DataLoader, SyntheticDataGenerator, DataValidator
from bangladesh_water_management.modules import (
    GroundwaterManager,
    SalinityManager,
    SurfaceWaterManager,
    AgriculturalWaterManager,
    UrbanWaterManager
)

@pytest.fixture
def config_data():
    """Provides default configuration for tests."""
    return get_default_config()

@pytest.fixture
def data_loader(config_data):
    """Provides a DataLoader instance initialized with default config."""
    return DataLoader(config_data=config_data['data_settings'])

@pytest.fixture
def synthetic_data_generator(config_data):
    """Provides a SyntheticDataGenerator instance."""
    return SyntheticDataGenerator(config_data=config_data['data_settings'].get('synthetic_data_params', {}))

@pytest.fixture
def data_validator(config_data):
    """Provides a DataValidator instance."""
    return DataValidator(config_data=config_data['data_settings'].get('validation_rules', {}))

# --- Test Cases for Data Flow --- 

def test_dataloader_to_groundwater_manager(data_loader, config_data, data_validator):
    """Test data flow from DataLoader to GroundwaterManager."""
    # Mock DataLoader's load_data to return sample groundwater level data
    sample_gw_data = pd.DataFrame({
        'date': pd.to_datetime(['2023-01-01', '2023-02-01']),
        'well_id': ['W001', 'W001'],
        'gw_level_m': [10.5, 10.2]
    })
    data_loader.load_data = MagicMock(return_value=sample_gw_data)
    
    # Validate the sample data (optional, but good practice)
    is_valid, _ = data_validator.validate_data(sample_gw_data, 'groundwater')
    assert is_valid

    gw_manager = GroundwaterManager(config_data=config_data['groundwater_settings'], global_config=config_data)
    
    # Simulate a method in GroundwaterManager that would use this data
    # For this test, we assume simulate_depletion might take historical_levels
    gw_manager.simulate_depletion = MagicMock(return_value={})
    gw_manager.simulate_depletion(year=2023, historical_levels=sample_gw_data)
    
    gw_manager.simulate_depletion.assert_called_once()
    # Check if the data was passed correctly (e.g., by inspecting call_args if needed)
    # args, kwargs = gw_manager.simulate_depletion.call_args
    # pd.testing.assert_frame_equal(kwargs['historical_levels'], sample_gw_data)

def test_synthetic_met_data_to_surface_water_manager(synthetic_data_generator, config_data, data_validator):
    """Test flow of synthetic meteorological data to SurfaceWaterManager."""
    sample_met_data = synthetic_data_generator.generate_meteorological_data(
        sites=['SiteA'], 
        start_date='2023-01-01', 
        end_date='2023-01-31',
        variables=['precipitation_mm', 'temperature_c']
    )
    assert not sample_met_data.empty
    is_valid, _ = data_validator.validate_data(sample_met_data, 'meteorological')
    assert is_valid

    sw_manager = SurfaceWaterManager(config_data=config_data['surface_water_settings'], global_config=config_data)
    sw_manager.simulate_river_flow = MagicMock(return_value=pd.DataFrame())
    
    # Assume simulate_river_flow uses meteorological data
    sw_manager.simulate_river_flow(year=2023, climate_scenario='baseline', meteorological_data=sample_met_data)
    sw_manager.simulate_river_flow.assert_called_once()
    # args, kwargs = sw_manager.simulate_river_flow.call_args
    # pd.testing.assert_frame_equal(kwargs['meteorological_data'], sample_met_data)

def test_dataloader_agri_data_to_agricultural_manager(data_loader, config_data, data_validator):
    """Test data flow from DataLoader for agricultural data to AgriculturalWaterManager."""
    sample_agri_data = pd.DataFrame({
        'year': [2022, 2023],
        'crop_area_ha': [100000, 102000],
        'yield_ton_ha': [3.5, 3.6]
    })
    data_loader.load_data = MagicMock(return_value=sample_agri_data)
    is_valid, _ = data_validator.validate_data(sample_agri_data, 'agricultural')
    assert is_valid

    ag_manager = AgriculturalWaterManager(config_data=config_data['agricultural_settings'], global_config=config_data)
    ag_manager.calculate_irrigation_demand = MagicMock(return_value={})
    
    ag_manager.calculate_irrigation_demand(year=2023, crop_production_data=sample_agri_data)
    ag_manager.calculate_irrigation_demand.assert_called_once()

def test_dataloader_urban_data_to_urban_manager(data_loader, config_data, data_validator):
    """Test data flow from DataLoader for urban water data to UrbanWaterManager."""
    sample_urban_data = pd.DataFrame({
        'city_id': ['Dhaka', 'Chittagong'],
        'population': [20_000_000, 5_000_000],
        'water_consumption_lpcd': [150, 140]
    })
    data_loader.load_data = MagicMock(return_value=sample_urban_data)
    is_valid, _ = data_validator.validate_data(sample_urban_data, 'urban_water')
    assert is_valid

    urban_manager = UrbanWaterManager(config_data=config_data['urban_water_settings'], global_config=config_data)
    urban_manager.calculate_urban_water_demand = MagicMock(return_value={})

    urban_manager.calculate_urban_water_demand(year=2023, urban_char_data=sample_urban_data)
    urban_manager.calculate_urban_water_demand.assert_called_once()


@patch('bangladesh_water_management.data.data_loader.pd.read_csv') # Mock where read_csv is used
def test_data_loader_file_loading_and_validation(mock_read_csv, data_loader, data_validator, config_data):
    """Test loading data from a file, then validating it."""
    # Sample CSV content for meteorological data
    csv_data_content = "date,station_id,precipitation_mm,temperature_c\n2023-01-01,S1,5.0,22.5\n2023-01-02,S1,0.0,23.0"
    mock_read_csv.return_value = pd.read_csv(pd.io.common.StringIO(csv_data_content))

    # Assume a schema for 'meteorological_csv' is defined in config
    # For simplicity, we'll use the generic 'meteorological' schema for validation
    if 'file_sources' not in config_data['data_settings']:
        config_data['data_settings']['file_sources'] = {}
    config_data['data_settings']['file_sources']['meteo_daily'] = {
        'path': 'fake/path/meteo.csv',
        'format': 'csv',
        'schema_name': 'meteorological' # Link to a validation schema
    }
    data_loader_reconfigured = DataLoader(config_data=config_data['data_settings'])

    loaded_data = data_loader_reconfigured.load_data_from_file(source_name='meteo_daily')
    assert not loaded_data.empty
    mock_read_csv.assert_called_once_with('fake/path/meteo.csv')

    is_valid, report = data_validator.validate_data(loaded_data, 'meteorological')
    assert is_valid, f"Data validation failed: {report}"
    assert loaded_data['precipitation_mm'].iloc[0] == 5.0

# More tests could include:
# - Data transformation steps if any are performed by DataLoader before passing to managers.
# - Integration with DataValidator to ensure data is cleaned/validated before use.
# - Scenarios where data from multiple sources needs to be merged or combined.
# - Error handling if data is missing or in an incorrect format.